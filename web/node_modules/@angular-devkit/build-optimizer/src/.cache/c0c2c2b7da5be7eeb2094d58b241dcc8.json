{"remainingRequest":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Server\\www\\portfolio\\web\\node_modules\\three\\examples\\js\\effects\\OutlineEffect.js","dependencies":[{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\three\\examples\\js\\effects\\OutlineEffect.js","mtime":1524602594759},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\imports-loader\\index.js","mtime":1524602776409},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\exports-loader\\index.js","mtime":1524602776409},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518922501563},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518922507228}],"contextDependencies":[],"result":["/**\n * @author takahirox / http://github.com/takahirox/\n *\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * // How to set default outline parameters\n * new THREE.OutlineEffect( renderer, {\n * \tdefaultThickNess: 0.01,\n * \tdefaultColor: new THREE.Color( 0x888888 ),\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.outlineParameters = {\n * \tthickNess: 0.01,\n * \tcolor: new THREE.Color( 0x888888 ),\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n *\n * TODO\n *  - support shader material without objectNormal in its vertexShader\n */\n\nTHREE.OutlineEffect = function ( renderer, parameters ) {\n\n\tparameters = parameters || {};\n\n\tthis.enabled = true;\n\n\tvar defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\tvar defaultColor = parameters.defaultColor !== undefined ? parameters.defaultColor : new THREE.Color( 0x000000 );\n\tvar defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\tvar defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t// object.material.uuid -> outlineMaterial or\n\t// object.material[ n ].uuid -> outlineMaterial\n\t// save at the outline material creation and release\n\t// if it's unused removeThresholdCount frames\n\t// unless keepAlive is true.\n\tvar cache = {};\n\n\tvar removeThresholdCount = 60;\n\n\t// outlineMaterial.uuid -> object.material or\n\t// outlineMaterial.uuid -> object.material[ n ]\n\t// save before render and release after render.\n\tvar originalMaterials = {};\n\n\t// object.uuid -> originalOnBeforeRender\n\t// save before render and release after render.\n\tvar originalOnBeforeRenders = {};\n\n\t//this.cache = cache;  // for debug\n\n\t// copied from WebGLPrograms and removed some materials\n\tvar shaderIDs = {\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical'\n\t};\n\n\tvar uniformsChunk = {\n\t\toutlineThickness: { type: \"f\", value: defaultThickness },\n\t\toutlineColor: { type: \"c\", value: defaultColor },\n\t\toutlineAlpha: { type: \"f\", value: defaultAlpha }\n\t};\n\n\tvar vertexShaderChunk = [\n\n\t\t\"#include <fog_pars_vertex>\",\n\n\t\t\"uniform float outlineThickness;\",\n\n\t\t\"vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\",\n\n\t\t\"\tfloat thickness = outlineThickness;\",\n\t\t\"\tconst float ratio = 1.0;\", // TODO: support outline thickness ratio for each vertex\n\t\t\"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\",\n\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\"\tvec4 norm = normalize( pos - pos2 );\",\n\t\t\"\treturn pos + norm * thickness * pos.w * ratio;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" );\n\n\tvar vertexShaderChunk2 = [\n\n\t\t\"#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )\",\n\t\t\"\t#ifndef USE_ENVMAP\",\n\t\t\"\t\tvec3 objectNormal = normalize( normal );\",\n\t\t\"\t#endif\",\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\t\t\"\tobjectNormal = -objectNormal;\",\n\t\t\"#endif\",\n\n\t\t\"#ifdef DECLARE_TRANSFORMED\",\n\t\t\"\tvec3 transformed = vec3( position );\",\n\t\t\"#endif\",\n\n\t\t\"gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\",\n\n\t\t\"#include <fog_vertex>\"\n\n\t].join( \"\\n\" );\n\n\tvar fragmentShader = [\n\n\t\t\"#include <common>\",\n\t\t\"#include <fog_pars_fragment>\",\n\n\t\t\"uniform vec3 outlineColor;\",\n\t\t\"uniform float outlineAlpha;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\n\n\t\t\"\t#include <fog_fragment>\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" );\n\n\tfunction createInvisibleMaterial() {\n\n\t\treturn new THREE.ShaderMaterial( { name: 'invisible', visible: false } );\n\n\t}\n\n\tfunction createMaterial( originalMaterial ) {\n\n\t\tvar shaderID = shaderIDs[ originalMaterial.type ];\n\t\tvar originalUniforms, originalVertexShader;\n\t\tvar outlineParameters = originalMaterial.outlineParameters;\n\n\t\tif ( shaderID !== undefined ) {\n\n\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\n\t\t\toriginalUniforms = shader.uniforms;\n\t\t\toriginalVertexShader = shader.vertexShader;\n\n\t\t} else if ( originalMaterial.isRawShaderMaterial === true ) {\n\n\t\t\toriginalUniforms = originalMaterial.uniforms;\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\n\n\t\t\tif ( ! /attribute\\s+vec3\\s+position\\s*;/.test( originalVertexShader ) ||\n\t\t\t     ! /attribute\\s+vec3\\s+normal\\s*;/.test( originalVertexShader ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.OutlineEffect requires both vec3 position and normal attributes in vertex shader, ' +\n\t\t\t\t              'does not draw outline for ' + originalMaterial.name + '(uuid:' + originalMaterial.uuid + ') material.' );\n\n\t\t\t\treturn createInvisibleMaterial();\n\n\t\t\t}\n\n\t\t} else if ( originalMaterial.isShaderMaterial === true ) {\n\n\t\t\toriginalUniforms = originalMaterial.uniforms;\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\n\n\t\t} else {\n\n\t\t\treturn createInvisibleMaterial();\n\n\t\t}\n\n\t\tvar uniforms = Object.assign( {}, originalUniforms, uniformsChunk );\n\n\t\tvar vertexShader = originalVertexShader\n\t\t\t\t\t// put vertexShaderChunk right before \"void main() {...}\"\n\t\t\t\t\t.replace( /void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + '\\nvoid main()' )\n\t\t\t\t\t// put vertexShaderChunk2 the end of \"void main() {...}\"\n\t\t\t\t\t// Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n\t\t\t\t\t.replace( /\\}\\s*$/, vertexShaderChunk2 + '\\n}' )\n\t\t\t\t\t// remove any light related lines\n\t\t\t\t\t// Note: here is very sensitive to originalVertexShader\n\t\t\t\t\t// TODO: consider safer way\n\t\t\t\t\t.replace( /#include\\s+<[\\w_]*light[\\w_]*>/g, '' );\n\n\t\tvar defines = {};\n\n\t\tif ( ! /vec3\\s+transformed\\s*=/.test( originalVertexShader ) &&\n\t\t     ! /#include\\s+<begin_vertex>/.test( originalVertexShader ) ) defines.DECLARE_TRANSFORMED = true;\n\n\t\treturn new THREE.ShaderMaterial( {\n\t\t\tdefines: defines,\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tside: THREE.BackSide,\n\t\t\t//wireframe: true,\n\t\t\tskinning: false,\n\t\t\tmorphTargets: false,\n\t\t\tmorphNormals: false,\n\t\t\tfog: false\n\t\t} );\n\n\t}\n\n\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\tvar data = cache[ originalMaterial.uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tmaterial: createMaterial( originalMaterial ),\n\t\t\t\tused: true,\n\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\tcount: 0\n\t\t\t};\n\n\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t}\n\n\t\tdata.used = true;\n\n\t\treturn data.material;\n\n\t}\n\n\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\tvar outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\treturn outlineMaterial;\n\n\t}\n\n\tfunction setOutlineMaterial( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t}\n\n\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\tobject.onBeforeRender = onBeforeRender;\n\n\t}\n\n\tfunction restoreOriginalMaterial( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t}\n\n\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t}\n\n\tfunction onBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t// just in case\n\t\tif ( originalMaterial === undefined ) return;\n\n\t\tupdateUniforms( material, originalMaterial );\n\n\t}\n\n\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\tvar outlineParameters = originalMaterial.outlineParameters;\n\n\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.copy( outlineParameters.color );\n\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t}\n\n\t}\n\n\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\tif ( material.name === 'invisible' ) return;\n\n\t\tvar outlineParameters = originalMaterial.outlineParameters;\n\n\t\tmaterial.skinning = originalMaterial.skinning;\n\t\tmaterial.morphTargets = originalMaterial.morphTargets;\n\t\tmaterial.morphNormals = originalMaterial.morphNormals;\n\t\tmaterial.fog = originalMaterial.fog;\n\n\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\tmaterial.visible = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t}\n\n\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t} else {\n\n\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t}\n\n\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t}\n\n\tfunction cleanupCache() {\n\n\t\tvar keys;\n\n\t\t// clear originialMaterials\n\t\tkeys = Object.keys( originalMaterials );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t}\n\n\t\t// clear originalOnBeforeRenders\n\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t}\n\n\t\t// remove unused outlineMaterial from cache\n\t\tkeys = Object.keys( cache );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tvar key = keys[ i ];\n\n\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\tcache[ key ].count++;\n\n\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcache[ key ].used = false;\n\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( this.enabled === false ) {\n\n\t\t\trenderer.render( scene, camera, renderTarget, forceClear );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = this.autoClear;\n\n\t\t// 1. render normally\n\t\trenderer.render( scene, camera, renderTarget, forceClear );\n\n\t\t// 2. render outline\n\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\n\t\tvar currentSceneBackground = scene.background;\n\t\tvar currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\tscene.autoUpdate = false;\n\t\tscene.background = null;\n\t\trenderer.autoClear = false;\n\t\trenderer.shadowMap.enabled = false;\n\n\t\tscene.traverse( setOutlineMaterial );\n\n\t\trenderer.render( scene, camera, renderTarget );\n\n\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\tcleanupCache();\n\n\t\tscene.autoUpdate = currentSceneAutoUpdate;\n\t\tscene.background = currentSceneBackground;\n\t\trenderer.autoClear = currentAutoClear;\n\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t};\n\n\t/*\n\t * See #9918\n\t *\n\t * The following property copies and wrapper methods enable\n\t * THREE.OutlineEffect to be called from other *Effect, like\n\t *\n\t * effect = new THREE.VREffect( new THREE.OutlineEffect( renderer ) );\n\t *\n\t * function render () {\n\t *\n \t * \teffect.render( scene, camera );\n\t *\n\t * }\n\t */\n\tthis.autoClear = renderer.autoClear;\n\tthis.domElement = renderer.domElement;\n\tthis.shadowMap = renderer.shadowMap;\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\trenderer.clear( color, depth, stencil );\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn renderer.getPixelRatio();\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\trenderer.setPixelRatio( value );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn renderer.getSize();\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\trenderer.setSize( width, height, updateStyle );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\trenderer.setViewport( x, y, width, height );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\trenderer.setScissor( x, y, width, height );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\trenderer.setScissorTest( boolean );\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t};\n\n};\n",null]}