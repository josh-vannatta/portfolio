{"remainingRequest":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Server\\www\\portfolio\\web\\node_modules\\ngx-page-scroll\\src\\ngx-page-scroll-instance.js","dependencies":[{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\ngx-page-scroll\\src\\ngx-page-scroll-instance.js","mtime":1521614071968},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518922501563},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518922507228}],"contextDependencies":[],"result":["import { EventEmitter, isDevMode } from '@angular/core';\r\nimport { PageScrollConfig } from './ngx-page-scroll-config';\r\nimport { PageScrollUtilService as Util } from './ngx-page-scroll-util.service';\r\n/**\r\n * Represents a scrolling action\r\n */\r\nvar PageScrollInstance = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Private constructor, requires the properties assumed to be the bare minimum.\r\n     * Use the factory methods to create instances:\r\n     *      {@link PageScrollInstance#simpleInstance}\r\n     *      {@link PageScrollInstance#newInstance}\r\n     * @param namespace\r\n     * @param document\r\n     */\r\n    function PageScrollInstance(namespace, document) {\r\n        /**\r\n         * These properties will be set during instance construction and default to their defaults from PageScrollConfig\r\n         */\r\n        /* A namespace to \"group\" scroll animations together and stopping some does not stop others */\r\n        this._namespace = PageScrollConfig._defaultNamespace;\r\n        /* Whether we scroll vertically (true) or horizontally (false) */\r\n        this._verticalScrolling = PageScrollConfig.defaultIsVerticalScrolling;\r\n        /* Offset in px that the animation should stop above that target element */\r\n        this._offset = PageScrollConfig.defaultScrollOffset;\r\n        /* Duration in milliseconds the scroll animation should last */\r\n        this._duration = PageScrollConfig.defaultDuration;\r\n        /* Easing function to manipulate the scrollTop/scrollLeft value over time */\r\n        this._easingLogic = PageScrollConfig.defaultEasingLogic;\r\n        /* Boolean whether the scroll animation should stop on user interruption or not */\r\n        this._interruptible = PageScrollConfig.defaultInterruptible;\r\n        /* Whether the advanded offset calculation for inline scrolling should be used */\r\n        this._advancedInlineOffsetCalculation = PageScrollConfig.defaultAdvancedInlineOffsetCalculation;\r\n        /* Event emitter to notify the world about the scrolling */\r\n        this._pageScrollFinish = new EventEmitter();\r\n        /**\r\n         * These properties will be set/manipulated if the scroll animation starts\r\n         */\r\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\r\n        this._startScrollPosition = 0;\r\n        /* Whether an interrupt listener is attached to the body or not */\r\n        this._interruptListenersAttached = false;\r\n        /* References to the timer instance that is used to perform the scroll animation to be\r\n         able to clear it on animation end*/\r\n        this._timer = null;\r\n        this._namespace = namespace;\r\n        this.document = document;\r\n    }\r\n    /*\r\n     * Factory methods for instance creation\r\n     */\r\n    PageScrollInstance.simpleInstance = function (document, scrollTarget, namespace) {\r\n        return PageScrollInstance.newInstance({\r\n            document: document,\r\n            scrollTarget: scrollTarget,\r\n            namespace: namespace\r\n        });\r\n    };\r\n    PageScrollInstance.newInstance = function (options) {\r\n        if (Util.isUndefinedOrNull(options.namespace) || options.namespace.length <= 0) {\r\n            options.namespace = PageScrollConfig._defaultNamespace;\r\n        }\r\n        var pageScrollInstance = new PageScrollInstance(options.namespace, document);\r\n        if (Util.isUndefinedOrNull(options.scrollingViews) || options.scrollingViews.length === 0) {\r\n            pageScrollInstance._isInlineScrolling = false;\r\n            pageScrollInstance._scrollingViews = [document.documentElement, document.body, document.body.parentNode];\r\n        }\r\n        else {\r\n            pageScrollInstance._isInlineScrolling = true;\r\n            pageScrollInstance._scrollingViews = options.scrollingViews;\r\n        }\r\n        pageScrollInstance._scrollTarget = options.scrollTarget;\r\n        if (!Util.isUndefinedOrNull(options.verticalScrolling)) {\r\n            pageScrollInstance._verticalScrolling = options.verticalScrolling;\r\n        }\r\n        if (!Util.isUndefinedOrNull(options.pageScrollOffset)) {\r\n            pageScrollInstance._offset = options.pageScrollOffset;\r\n        }\r\n        if (!Util.isUndefinedOrNull(options.pageScrollEasingLogic)) {\r\n            pageScrollInstance._easingLogic = options.pageScrollEasingLogic;\r\n        }\r\n        if (Util.isUndefinedOrNull(options.pageScrollDuration) && !Util.isUndefinedOrNull(options.pageScrollSpeed)) {\r\n            // No duration specified in the options, only in this case we use the speed option when present\r\n            pageScrollInstance._speed = options.pageScrollSpeed;\r\n            pageScrollInstance._duration = undefined;\r\n        }\r\n        else if (!Util.isUndefinedOrNull(options.pageScrollDuration)) {\r\n            pageScrollInstance._duration = options.pageScrollDuration;\r\n        }\r\n        if (!Util.isUndefinedOrNull(options.pageScrollFinishListener)) {\r\n            pageScrollInstance._pageScrollFinish = options.pageScrollFinishListener;\r\n        }\r\n        pageScrollInstance._interruptible = options.pageScrollInterruptible ||\r\n            (Util.isUndefinedOrNull(options.pageScrollInterruptible) && PageScrollConfig.defaultInterruptible);\r\n        pageScrollInstance._advancedInlineOffsetCalculation = options.advancedInlineOffsetCalculation ||\r\n            (Util.isUndefinedOrNull(options.advancedInlineOffsetCalculation) &&\r\n                PageScrollConfig.defaultAdvancedInlineOffsetCalculation);\r\n        return pageScrollInstance;\r\n    };\r\n    PageScrollInstance.prototype.getScrollPropertyValue = function (scrollingView) {\r\n        if (!this.verticalScrolling) {\r\n            return scrollingView.scrollLeft;\r\n        }\r\n        return scrollingView.scrollTop;\r\n    };\r\n    /**\r\n     * Extract the exact location of the scrollTarget element.\r\n     *\r\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\r\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\r\n    PageScrollInstance.prototype.extractScrollTargetPosition = function () {\r\n        var scrollTargetElement;\r\n        if (typeof this._scrollTarget === 'string') {\r\n            var targetSelector = this._scrollTarget;\r\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\r\n                // It's an id selector and a valid id, as it does not contain any white space characters\r\n                scrollTargetElement = this.document.getElementById(targetSelector.substr(1));\r\n            }\r\n            else {\r\n                scrollTargetElement = this.document.querySelector(targetSelector);\r\n            }\r\n        }\r\n        else {\r\n            scrollTargetElement = this._scrollTarget;\r\n        }\r\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\r\n            // Scroll target not found\r\n            return { top: NaN, left: NaN };\r\n        }\r\n        if (this._isInlineScrolling) {\r\n            var position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\r\n            if (this._advancedInlineOffsetCalculation && this.scrollingViews.length === 1) {\r\n                var accumulatedParentsPos = { top: 0, left: 0 };\r\n                // not named window to make sure we're not getting the global window variable by accident\r\n                var theWindow = scrollTargetElement.ownerDocument.defaultView;\r\n                var parentFound = false;\r\n                // Start parent is the immediate parent\r\n                var parent_1 = scrollTargetElement.parentElement;\r\n                // Iterate upwards all parents\r\n                while (!parentFound && !Util.isUndefinedOrNull(parent_1)) {\r\n                    if (theWindow.getComputedStyle(parent_1).getPropertyValue('position') === 'relative') {\r\n                        accumulatedParentsPos.top += parent_1.offsetTop;\r\n                        accumulatedParentsPos.left += parent_1.offsetLeft;\r\n                    }\r\n                    // Next iteration\r\n                    parent_1 = parent_1.parentElement;\r\n                    parentFound = parent_1 === this.scrollingViews[0];\r\n                }\r\n                if (parentFound) {\r\n                    // Only use the results if we found the parent, otherwise we accumulated too much anyway\r\n                    position.top += accumulatedParentsPos.top;\r\n                    position.left += accumulatedParentsPos.left;\r\n                }\r\n                else {\r\n                    if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\r\n                        console.warn('Unable to find nested scrolling targets parent!');\r\n                    }\r\n                }\r\n            }\r\n            return position;\r\n        }\r\n        return Util.extractElementPosition(this.document, scrollTargetElement);\r\n    };\r\n    /**\r\n     * Get the top offset of the scroll animation.\r\n     * This automatically takes the offset location of the scrolling container/scrolling view\r\n     * into account (for nested/inline scrolling).\r\n     *\r\n     * @returns {number}\r\n     */\r\n    PageScrollInstance.prototype.getCurrentOffset = function () {\r\n        return this._offset;\r\n    };\r\n    /**\r\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollingViews to the provided value\r\n     * @param position\r\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\r\n     *          false if it failed for all ScrollingViews, meaning that we should stop the animation\r\n     *          (probably because we're at the end of the scrolling region)\r\n     */\r\n    PageScrollInstance.prototype.setScrollPosition = function (position) {\r\n        var _this = this;\r\n        if (PageScrollConfig._logLevel >= 5 && isDevMode()) {\r\n            console.warn('Scroll Position: ' + position);\r\n        }\r\n        // Set the new scrollTop/scrollLeft to all scrollingViews elements\r\n        return this.scrollingViews.reduce(function (oneAlreadyWorked, scrollingView) {\r\n            var startScrollPropertyValue = _this.getScrollPropertyValue(scrollingView);\r\n            if (scrollingView && !Util.isUndefinedOrNull(startScrollPropertyValue)) {\r\n                var scrollDistance = Math.abs(startScrollPropertyValue - position);\r\n                // The movement we need to perform is less than 2px\r\n                // This we consider a small movement which some browser may not perform when\r\n                // changing the scrollTop/scrollLeft property\r\n                // Thus in this cases we do not stop the scroll animation, although setting the\r\n                // scrollTop/scrollLeft value \"fails\"\r\n                var isSmallMovement = scrollDistance < PageScrollConfig._minScrollDistance;\r\n                if (!_this.verticalScrolling) {\r\n                    scrollingView.scrollLeft = position;\r\n                }\r\n                else {\r\n                    scrollingView.scrollTop = position;\r\n                }\r\n                // Return true of setting the new scrollTop/scrollLeft value worked\r\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\r\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\r\n                // set due to dpi or rounding irregularities)\r\n                if (isSmallMovement || scrollDistance > Math.abs(_this.getScrollPropertyValue(scrollingView) - position)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return oneAlreadyWorked;\r\n        }, false);\r\n    };\r\n    /**\r\n     * Trigger firing a animation finish event\r\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\r\n     */\r\n    PageScrollInstance.prototype.fireEvent = function (value) {\r\n        if (this._pageScrollFinish) {\r\n            this._pageScrollFinish.emit(value);\r\n        }\r\n    };\r\n    /**\r\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\r\n     * will be called if any of the attached events is fired.\r\n     *\r\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\r\n     *\r\n     * @param interruptReporter\r\n     */\r\n    PageScrollInstance.prototype.attachInterruptListeners = function (interruptReporter) {\r\n        var _this = this;\r\n        if (this._interruptListenersAttached) {\r\n            // Detach possibly existing listeners first\r\n            this.detachInterruptListeners();\r\n        }\r\n        this._interruptListener = function (event) {\r\n            interruptReporter.report(event, _this);\r\n        };\r\n        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.addEventListener(event, _this._interruptListener); });\r\n        this._interruptListenersAttached = true;\r\n    };\r\n    /**\r\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\r\n     * interrupt\" events.\r\n     */\r\n    PageScrollInstance.prototype.detachInterruptListeners = function () {\r\n        var _this = this;\r\n        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.removeEventListener(event, _this._interruptListener); });\r\n        this._interruptListenersAttached = false;\r\n    };\r\n    Object.defineProperty(PageScrollInstance.prototype, \"namespace\", {\r\n        get: function () {\r\n            return this._namespace;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"scrollTarget\", {\r\n        get: function () {\r\n            return this._scrollTarget;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"verticalScrolling\", {\r\n        get: function () {\r\n            return this._verticalScrolling;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"scrollingViews\", {\r\n        get: function () {\r\n            return this._scrollingViews;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"startScrollPosition\", {\r\n        get: function () {\r\n            return this._startScrollPosition;\r\n        },\r\n        set: function (value) {\r\n            this._startScrollPosition = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"targetScrollPosition\", {\r\n        get: function () {\r\n            return this._targetScrollPosition;\r\n        },\r\n        set: function (value) {\r\n            this._targetScrollPosition = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"distanceToScroll\", {\r\n        get: function () {\r\n            return this._distanceToScroll;\r\n        },\r\n        set: function (value) {\r\n            this._distanceToScroll = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"executionDuration\", {\r\n        get: function () {\r\n            return this._executionDuration;\r\n        },\r\n        set: function (value) {\r\n            this._executionDuration = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"duration\", {\r\n        get: function () {\r\n            return this._duration;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"speed\", {\r\n        get: function () {\r\n            return this._speed;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"easingLogic\", {\r\n        get: function () {\r\n            return this._easingLogic;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"interruptible\", {\r\n        get: function () {\r\n            return this._interruptible;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"startTime\", {\r\n        get: function () {\r\n            return this._startTime;\r\n        },\r\n        set: function (value) {\r\n            this._startTime = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"endTime\", {\r\n        get: function () {\r\n            return this._endTime;\r\n        },\r\n        set: function (value) {\r\n            this._endTime = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"timer\", {\r\n        get: function () {\r\n            return this._timer;\r\n        },\r\n        set: function (value) {\r\n            this._timer = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PageScrollInstance.prototype, \"interruptListenersAttached\", {\r\n        get: function () {\r\n            return this._interruptListenersAttached;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return PageScrollInstance;\r\n}());\r\nexport { PageScrollInstance };\r\n",null]}