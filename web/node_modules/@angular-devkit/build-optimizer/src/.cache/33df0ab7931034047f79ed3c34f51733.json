{"remainingRequest":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Server\\www\\portfolio\\web\\node_modules\\ngx-page-scroll\\src\\ngx-page-scroll-config.js","dependencies":[{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\ngx-page-scroll\\src\\ngx-page-scroll-config.js","mtime":1521614071974},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518922501563},{"path":"C:\\Server\\www\\portfolio\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518922507228}],"contextDependencies":[],"result":["var EasingLogic = /*@__PURE__*/ (function () {\r\n    function EasingLogic() {\r\n    }\r\n    return EasingLogic;\r\n}());\r\nexport { EasingLogic };\r\nvar PageScrollConfig = /*@__PURE__*/ (function () {\r\n    function PageScrollConfig() {\r\n    }\r\n    Object.defineProperty(PageScrollConfig, \"defaultEasingLogic\", {\r\n        // Getter and setter to avoid auto completion to suggest calling the method\r\n        get: function () {\r\n            return PageScrollConfig._easingLogic;\r\n        },\r\n        set: function (easingLogic) {\r\n            PageScrollConfig._easingLogic = easingLogic;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * The number of milliseconds to wait till updating the scroll position again.\r\n     * Small amounts may produce smoother animations but require more processing power.\r\n     * @type {number}\r\n     */\r\n    PageScrollConfig._interval = 10;\r\n    /**\r\n     * The amount of pixels that need to be between the current scrollTop/scrollLeft position\r\n     * and the target position the cause a scroll animation. In case distance is below\r\n     * this threshold, an immediate jump will be performed.\r\n     * Due to dpi or rounding irregularities in browsers floating point numbers for scrollTop/scrollLeft values\r\n     * are possible, making a === comparison of current scrollTop or scrollLeft and target scrollPosition error-prone.\r\n     * @type {number}\r\n     */\r\n    PageScrollConfig._minScrollDistance = 2;\r\n    /**\r\n     * Name of the default namespace.\r\n     * @type {string}\r\n     */\r\n    PageScrollConfig._defaultNamespace = 'default';\r\n    /**\r\n     * Whether by default the scrolling should happen in vertical direction (by manipulating the scrollTop property)\r\n     * (= true; default) or in horizontal direction (by manipulating the scrollLeft property) (= false\r\n     * @type {boolean}\r\n     */\r\n    PageScrollConfig.defaultIsVerticalScrolling = true;\r\n    /**\r\n     * How many console logs should be emitted. Also influenced by angular mode (dev or prod mode)\r\n     * 0: No logs, neither in dev nor in prod mode\r\n     * 1: Animation errors in dev mode, no logs in prod mode\r\n     * 2: Animation errors in dev and prod mode\r\n     * 5: Animation errors in dev and all scroll position values that get set; animation errors in prod mode\r\n     * @type {number}\r\n     */\r\n    PageScrollConfig._logLevel = 1;\r\n    /**\r\n     * The duration how long a scrollTo animation should last by default.\r\n     * May be overridden using the page-scroll-duration attribute on a single ngxPageScroll instance.\r\n     * @type {number}\r\n     */\r\n    PageScrollConfig.defaultDuration = 1250;\r\n    /**\r\n     * The distance in pixels above scroll target where the animation should stop. Setting a positive number results in\r\n     * the scroll target being more in the middle of the screen, negative numbers will produce scrolling \"too far\"\r\n     * @type {number}\r\n     */\r\n    PageScrollConfig.defaultScrollOffset = 0;\r\n    /**\r\n     * Whether by default for inline scroll animations the advanced offset calculation should take place (true) or\r\n     * not (false). Default is false.\r\n     * The advanced offset calculation will traverse the DOM tree upwards, starting at the scrollTarget, until it finds\r\n     * the scrollingView container element. Along the way the offset positions of the relative positioned\r\n     * (position: relative) elements will be taken into account for calculating the target elements position.\r\n     * @type {boolean}\r\n     */\r\n    PageScrollConfig.defaultAdvancedInlineOffsetCalculation = false;\r\n    /**\r\n     * The events that are listened to on the body to decide whether a scroll animation has been interfered/interrupted by the user\r\n     * @type {string[]}\r\n     */\r\n    PageScrollConfig._interruptEvents = ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'];\r\n    /**\r\n     * The keys that are considered to interrupt a scroll animation (mainly the arrow keys). All other key presses will not stop the\r\n     * scroll animation.\r\n     * @type {number[]}\r\n     */\r\n    PageScrollConfig._interruptKeys = [33, 34, 35, 36, 38, 40];\r\n    /**\r\n     * Whether a scroll animation should be interruptible by user interaction (true) or not (false). If the user performs an\r\n     * interrupting event while a scroll animation takes place, the scroll animation stops.\r\n     * @type {boolean}\r\n     */\r\n    PageScrollConfig.defaultInterruptible = true;\r\n    PageScrollConfig._easingLogic = {\r\n        ease: function (t, b, c, d) {\r\n            // Linear easing\r\n            return c * t / d + b;\r\n        }\r\n    };\r\n    return PageScrollConfig;\r\n}());\r\nexport { PageScrollConfig };\r\n",null]}